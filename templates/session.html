<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session {{ code }} - Workshop Feedback</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="header-row">
                <div class="header-left">
                    <div>
                        <h1>Feedback Session</h1>
                        <p class="session-code">Code: <strong>{{ code }}</strong></p>
                    </div>
                    <button id="theme-toggle" class="theme-toggle" title="Toggle light/dark mode">
                        <svg id="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
                        <svg id="theme-icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
                        <span id="theme-label">Dark</span>
                    </button>
                </div>
                {% if is_host %}
                <div class="host-controls">
                    <button id="export-btn" class="btn">Export Markdown</button>
                    <button id="close-btn" class="btn btn-danger">End Session</button>
                </div>
                {% endif %}
            </div>
        </header>

        <main>
            <!-- Polls Section -->
            <div id="polls-section" class="polls-section">
                {% if is_host %}
                <button id="create-poll-btn" class="btn btn-primary" style="margin-bottom: 16px;">Create Poll</button>
                {% endif %}
                <div id="polls-list"></div>
            </div>

            <!-- New Feedback Form -->
            <div class="card feedback-form">
                <form id="feedback-form">
                    <textarea id="feedback-input" placeholder="Share your feedback or idea..." rows="3" required></textarea>
                    <button type="submit" class="btn btn-primary">Post Feedback</button>
                </form>
            </div>

            <!-- Feedback List -->
            <div id="feedback-list" class="feedback-list">
                <p class="empty-state">No feedback yet. Be the first to share!</p>
            </div>
        </main>
    </div>

    <!-- Create Poll Modal -->
    <div id="poll-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Create Poll</h2>
            <form id="poll-form">
                <label>Question</label>
                <input type="text" id="poll-question" placeholder="Enter your question..." required />
                <label>Options</label>
                <div id="poll-options">
                    <input type="text" class="poll-option" placeholder="Option 1" required />
                    <input type="text" class="poll-option" placeholder="Option 2" required />
                </div>
                <button type="button" id="add-option-btn" class="btn btn-small">+ Add Option</button>
                <div class="modal-actions">
                    <button type="button" id="cancel-poll-btn" class="btn">Cancel</button>
                    <button type="submit" class="btn btn-primary">Create Poll</button>
                </div>
            </form>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const SESSION_CODE = "{{ code }}";
        const IS_HOST = {{ 'true' if is_host else 'false' }};
        
        // Generate/retrieve anonymous user ID
        let userId = localStorage.getItem('feedback_user_id');
        if (!userId) {
            userId = 'anon_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('feedback_user_id', userId);
        }

        // Track voted items to show visual feedback
        let votedItems = JSON.parse(localStorage.getItem('voted_' + SESSION_CODE) || '[]');
        // Track poll votes: { pollId: optionIndex }
        let pollVotes = JSON.parse(localStorage.getItem('poll_votes_' + SESSION_CODE) || '{}');

        const socket = io();
        const feedbackList = document.getElementById('feedback-list');

        // Join the session room
        socket.emit('join', { code: SESSION_CODE });

        // Socket event handlers
        socket.on('joined', (data) => {
            renderFeedbacks(data.feedbacks || []);
            renderPolls(data.polls || []);
        });

        socket.on('feedback_added', (feedback) => {
            addFeedbackToList(feedback);
        });

        socket.on('comment_added', (data) => {
            addCommentToFeedback(data.feedback_id, data.comment);
        });

        socket.on('vote_updated', (data) => {
            updateVoteCount(data.item_id, data.votes, data.is_comment);
        });

        socket.on('error', (data) => {
            alert(data.message);
            window.location.href = '/';
        });

        socket.on('poll_created', (poll) => {
            renderPoll(poll);
        });

        socket.on('poll_updated', (data) => {
            updatePollResults(data.poll_id, data.votes);
        });

        // Render all feedbacks
        function renderFeedbacks(feedbacks) {
            if (feedbacks.length === 0) {
                feedbackList.innerHTML = '<p class="empty-state">No feedback yet. Be the first to share!</p>';
                return;
            }
            feedbackList.innerHTML = '';
            // Sort by votes descending
            feedbacks.sort((a, b) => b.votes - a.votes);
            feedbacks.forEach(fb => addFeedbackToList(fb, false));
        }

        // Relative time (e.g. "vor 5 Min.")
        function relativeTime(isoStr) {
            const date = new Date(isoStr);
            const now = new Date();
            const sec = Math.floor((now - date) / 1000);
            if (sec < 60) return 'gerade eben';
            const min = Math.floor(sec / 60);
            if (min < 60) return `vor ${min} Min.`;
            const h = Math.floor(min / 60);
            if (h < 24) return `vor ${h} Std.`;
            const d = Math.floor(h / 24);
            return `vor ${d} Tag${d > 1 ? 'en' : ''}`;
        }

        // Add a single feedback to the list
        function addFeedbackToList(feedback, prepend = true) {
            const emptyState = feedbackList.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            const hasVoted = votedItems.includes(feedback.id);
            const hasReplies = feedback.comments && feedback.comments.length > 0;
            const el = document.createElement('div');
            el.className = 'feedback-thread';
            el.id = 'thread-' + feedback.id;
            el.innerHTML = `
                <div class="feedback-item${hasReplies ? ' has-replies' : ''}">
                    ${hasReplies ? `<button class="collapse-btn" data-feedback-id="${feedback.id}" title="Thread ein-/ausklappen">−</button>` : ''}
                    <div class="comment-avatar">A</div>
                    <div class="comment-content">
                        <div class="comment-meta">
                            <span class="comment-author">Anonymous</span>
                            <span class="comment-sep">•</span>
                            <span class="comment-time">${relativeTime(feedback.created_at || new Date().toISOString())}</span>
                        </div>
                        <p class="comment-text">${escapeHtml(feedback.text)}</p>
                        <div class="comment-actions">
                            <button class="vote-btn ${hasVoted ? 'voted' : ''}" data-id="${feedback.id}" data-type="feedback">
                                <span class="arrow">▲</span>
                                <span class="vote-count" id="votes-${feedback.id}">${feedback.votes}</span>
                            </button>
                            <button class="reply-btn" data-id="${feedback.id}">Antworten</button>
                        </div>
                        <div class="comments" id="comments-${feedback.id}">
                            ${(feedback.comments || []).map(c => renderComment(c, feedback.id)).join('')}
                        </div>
                        <div class="reply-form" id="reply-form-${feedback.id}" style="display: none;">
                            <textarea placeholder="Antwort schreiben..." rows="2"></textarea>
                            <button class="btn btn-small submit-reply" data-id="${feedback.id}">Antworten</button>
                        </div>
                    </div>
                </div>
            `;

            if (prepend) {
                feedbackList.prepend(el);
            } else {
                feedbackList.appendChild(el);
            }
        }

        // Render a comment
        function renderComment(comment, feedbackId) {
            const hasVoted = votedItems.includes(comment.id);
            return `
                <div class="comment-item" id="comment-${comment.id}">
                    <div class="comment-avatar small">A</div>
                    <div class="comment-content">
                        <div class="comment-meta">
                            <span class="comment-author">Anonymous</span>
                            <span class="comment-sep">•</span>
                            <span class="comment-time">${relativeTime(comment.created_at || new Date().toISOString())}</span>
                        </div>
                        <p class="comment-text">${escapeHtml(comment.text)}</p>
                        <div class="comment-actions">
                            <button class="vote-btn ${hasVoted ? 'voted' : ''}" data-id="${comment.id}" data-type="comment" data-feedback-id="${feedbackId}">
                                <span class="arrow">▲</span>
                                <span class="vote-count" id="votes-${comment.id}">${comment.votes}</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Add comment to feedback
        function addCommentToFeedback(feedbackId, comment) {
            const commentsEl = document.getElementById('comments-' + feedbackId);
            if (commentsEl) {
                const feedbackItem = commentsEl.closest('.feedback-item');
                if (feedbackItem && !feedbackItem.classList.contains('has-replies')) {
                    feedbackItem.classList.add('has-replies');
                    const collapseBtn = document.createElement('button');
                    collapseBtn.className = 'collapse-btn';
                    collapseBtn.dataset.feedbackId = feedbackId;
                    collapseBtn.title = 'Thread ein-/ausklappen';
                    collapseBtn.textContent = '−';
                    feedbackItem.insertBefore(collapseBtn, feedbackItem.firstChild);
                }
                commentsEl.insertAdjacentHTML('beforeend', renderComment(comment, feedbackId));
            }
        }

        // Update vote count
        function updateVoteCount(itemId, votes, isComment) {
            const el = document.getElementById('votes-' + itemId);
            if (el) el.textContent = votes;
        }

        // Poll rendering
        function renderPolls(polls) {
            const container = document.getElementById('polls-list');
            container.innerHTML = '';
            polls.forEach(p => renderPoll(p));
        }

        function renderPoll(poll) {
            const container = document.getElementById('polls-list');
            const total = Object.values(poll.votes || {}).reduce((a, b) => a + b, 0);
            const myVote = pollVotes[poll.id];
            const el = document.createElement('div');
            el.className = 'card poll-card';
            el.id = 'poll-' + poll.id;
            el.innerHTML = `
                <h3 class="poll-question">${escapeHtml(poll.question)}</h3>
                <div class="poll-options">
                    ${(poll.options || []).map((opt, i) => {
                        const count = (poll.votes || {})[String(i)] || 0;
                        const pct = total > 0 ? (count / total * 100) : 0;
                        const isSelected = myVote === i;
                        return `
                            <div class="poll-option-row">
                                <button class="poll-option-btn ${isSelected ? 'selected' : ''}" data-poll-id="${poll.id}" data-option-index="${i}">
                                    <span class="poll-option-label">${escapeHtml(opt)}</span>
                                    <span class="poll-bar-container">
                                        <span class="poll-bar" style="width: ${pct}%"></span>
                                    </span>
                                    <span class="poll-count">${count}</span>
                                </button>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            container.appendChild(el);
        }

        function updatePollResults(pollId, votes) {
            const el = document.getElementById('poll-' + pollId);
            if (!el) return;
            const total = Object.values(votes).reduce((a, b) => a + b, 0);
            el.querySelectorAll('.poll-option-btn').forEach((btn, i) => {
                const count = votes[String(i)] || 0;
                const pct = total > 0 ? (count / total * 100) : 0;
                btn.querySelector('.poll-bar').style.width = pct + '%';
                btn.querySelector('.poll-count').textContent = count;
                btn.classList.toggle('selected', pollVotes[pollId] === i);
            });
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Event delegation for votes and replies
        feedbackList.addEventListener('click', (e) => {
            const voteBtn = e.target.closest('.vote-btn');
            if (voteBtn) {
                const itemId = voteBtn.dataset.id;
                const isComment = voteBtn.dataset.type === 'comment';
                const feedbackId = voteBtn.dataset.feedbackId;
                const alreadyVoted = votedItems.includes(itemId);

                socket.emit('vote', {
                    code: SESSION_CODE,
                    item_id: itemId,
                    user_id: userId,
                    is_comment: isComment,
                    feedback_id: feedbackId,
                    remove: alreadyVoted
                });

                if (alreadyVoted) {
                    voteBtn.classList.remove('voted');
                    votedItems = votedItems.filter(id => id !== itemId);
                } else {
                    voteBtn.classList.add('voted');
                    votedItems.push(itemId);
                }
                localStorage.setItem('voted_' + SESSION_CODE, JSON.stringify(votedItems));
            }

            const replyBtn = e.target.closest('.reply-btn');
            if (replyBtn) {
                const feedbackId = replyBtn.dataset.id;
                const form = document.getElementById('reply-form-' + feedbackId);
                form.style.display = form.style.display === 'none' ? 'block' : 'none';
            }

            const submitReply = e.target.closest('.submit-reply');
            if (submitReply) {
                const feedbackId = submitReply.dataset.id;
                const form = document.getElementById('reply-form-' + feedbackId);
                const textarea = form.querySelector('textarea');
                const text = textarea.value.trim();

                if (text) {
                    socket.emit('new_comment', {
                        code: SESSION_CODE,
                        feedback_id: feedbackId,
                        text: text
                    });
                    textarea.value = '';
                    form.style.display = 'none';
                }
            }
        });

        // Poll voting (single choice: click to vote, click same to remove)
        document.getElementById('polls-section').addEventListener('click', (e) => {
            const pollBtn = e.target.closest('.poll-option-btn');
            if (pollBtn) {
                const pollId = pollBtn.dataset.pollId;
                const optionIndex = parseInt(pollBtn.dataset.optionIndex, 10);
                const prevVote = pollVotes[pollId];
                const isRemoving = prevVote === optionIndex;
                if (isRemoving) {
                    delete pollVotes[pollId];
                } else {
                    pollVotes[pollId] = optionIndex;
                }
                localStorage.setItem('poll_votes_' + SESSION_CODE, JSON.stringify(pollVotes));
                socket.emit('poll_vote', {
                    code: SESSION_CODE,
                    poll_id: pollId,
                    option_index: optionIndex,
                    user_id: userId
                });
                pollBtn.closest('.poll-options').querySelectorAll('.poll-option-btn').forEach(b => b.classList.remove('selected'));
                if (!isRemoving) pollBtn.classList.add('selected');
            }
        });

        // Poll creation (host only)
        if (IS_HOST) {
            document.getElementById('create-poll-btn').addEventListener('click', () => {
                document.getElementById('poll-modal').style.display = 'flex';
            });
            document.getElementById('cancel-poll-btn').addEventListener('click', () => {
                document.getElementById('poll-modal').style.display = 'none';
            });
            document.getElementById('add-option-btn').addEventListener('click', () => {
                const opts = document.getElementById('poll-options');
                const n = opts.querySelectorAll('.poll-option').length + 1;
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'poll-option';
                input.placeholder = `Option ${n}`;
                opts.appendChild(input);
            });
            document.getElementById('poll-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const question = document.getElementById('poll-question').value.trim();
                const options = Array.from(document.querySelectorAll('.poll-option'))
                    .map(o => o.value.trim())
                    .filter(o => o);
                if (question && options.length >= 2) {
                    socket.emit('create_poll', {
                        code: SESSION_CODE,
                        question: question,
                        options: options
                    });
                    document.getElementById('poll-modal').style.display = 'none';
                    document.getElementById('poll-form').reset();
                    document.getElementById('poll-options').innerHTML = `
                        <input type="text" class="poll-option" placeholder="Option 1" required />
                        <input type="text" class="poll-option" placeholder="Option 2" required />
                    `;
                }
            });
        }

        // Submit new feedback
        document.getElementById('feedback-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('feedback-input');
            const text = input.value.trim();

            if (text) {
                socket.emit('new_feedback', {
                    code: SESSION_CODE,
                    text: text,
                    user_id: userId
                });
                input.value = '';
            }
        });

        // Theme toggle
        const themeToggle = document.getElementById('theme-toggle');
        const themeLabel = document.getElementById('theme-label');
        const iconSun = document.getElementById('theme-icon-sun');
        const iconMoon = document.getElementById('theme-icon-moon');
        const savedTheme = localStorage.getItem('feedback_theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        if (savedTheme === 'dark') {
            themeLabel.textContent = 'Dark';
            iconSun.style.display = 'none';
            iconMoon.style.display = 'block';
        } else {
            themeLabel.textContent = 'Light';
            iconSun.style.display = 'block';
            iconMoon.style.display = 'none';
        }
        themeToggle.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('feedback_theme', next);
            themeLabel.textContent = next === 'dark' ? 'Dark' : 'Light';
            iconSun.style.display = next === 'dark' ? 'none' : 'block';
            iconMoon.style.display = next === 'dark' ? 'block' : 'none';
        });

        // Collapse/expand threads
        feedbackList.addEventListener('click', (e) => {
            const collapseBtn = e.target.closest('.collapse-btn');
            if (collapseBtn) {
                const feedbackId = collapseBtn.dataset.feedbackId;
                const commentsEl = document.getElementById('comments-' + feedbackId);
                if (commentsEl) {
                    const comments = commentsEl.querySelectorAll('.comment-item');
                    const isCollapsed = collapseBtn.classList.contains('collapsed');
                    comments.forEach(c => c.classList.toggle('collapsed', !isCollapsed));
                    collapseBtn.classList.toggle('collapsed', !isCollapsed);
                }
            }
        });

        // Host controls
        if (IS_HOST) {
            document.getElementById('export-btn').addEventListener('click', async () => {
                const response = await fetch('/api/session/' + SESSION_CODE + '/export');
                const data = await response.json();
                
                const blob = new Blob([data.markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = data.filename;
                a.click();
                URL.revokeObjectURL(url);
            });

            document.getElementById('close-btn').addEventListener('click', async () => {
                if (confirm('End this session? This will export the feedback and delete the session.')) {
                    // Export first
                    const response = await fetch('/api/session/' + SESSION_CODE + '/export');
                    const data = await response.json();
                    
                    const blob = new Blob([data.markdown], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = data.filename;
                    a.click();
                    URL.revokeObjectURL(url);

                    // Then close
                    await fetch('/api/session/' + SESSION_CODE + '/close', { method: 'POST' });
                    window.location.href = '/';
                }
            });
        }
    </script>
</body>
</html>
